from vpython import *
import serial, time, math
from serial.tools import list_ports

# ---------- PORT ----------
def pick_port():
    ports = list(list_ports.comports())
    print("🔎 Detected serial ports:")
    for p in ports:
        print(f" - {p.device}: {p.description}")
    for p in ports:
        desc = (p.description or "").lower()
        if any(k in desc for k in ("cp210","silicon","ch340","usb-serial","esp32","wch","ftdi")):
            print(f"✅ Auto-selected: {p.device}")
            return p.device
    if ports:
        print(f"⚠️ No ESP32/USB-serial keywords found, falling back to first port: {ports[0].device}")
        return ports[0].device
    return None

PORT = pick_port()
BAUD = 115200

if not PORT:
    raise RuntimeError("❌ No COM ports detected. Is your ESP32 plugged in?")

try:
    ser = serial.Serial(PORT, BAUD, timeout=0.01)
    time.sleep(2.0)
    ser.reset_input_buffer()
    print(f"🚀 Connected on {PORT} at {BAUD} baud")
except Exception as e:
    raise RuntimeError(f"❌ Could not open {PORT}: {e}")

# ---------- Scene ----------
scene.title = "BNO wrist + two MPU finger bones (bend axis selectable)"
scene.range = 6
scene.background = color.white
scene.width = 1200
scene.height = 800
scene.forward = vector(-1, -1, -1)

# ---------- Geometry ----------
wrist_len = 4.0
bone1_len = 3.0
bone2_len = 3.0

wrist = box(length=wrist_len, width=2.0, height=0.6,
            opacity=0.7, color=color.orange, pos=vector(0,0,0))
bone1 = box(length=bone1_len, width=0.8, height=0.6,
            opacity=0.85, color=color.cyan)
bone2 = box(length=bone2_len, width=0.7, height=0.5,
            opacity=0.85, color=color.green)

hud = wtext(text="")

# ---------- Config ----------
BEND_AXIS_1 = "pitch"
BEND_AXIS_2 = "pitch"
SMOOTH = 0.15
GAIN_1 = 1.0
GAIN_2 = 0.5
SIGN_P1 = 1.0
SIGN_P2 = 1.0
USE_CLAMP = False
CLAMP_MIN_DEG = -5
CLAMP_MAX_DEG = 110

# ---------- Helpers ----------
y_up = vector(0,1,0)

def rpy_to_axis_up(roll, pitch, yaw):
    k = vector(math.cos(yaw)*math.cos(pitch),
               math.sin(pitch),
               math.sin(yaw)*math.cos(pitch))
    s = cross(k, y_up)
    v = cross(s, k)
    up = v*math.cos(roll) + cross(k, v)*math.sin(roll)
    return k, up

def clamp(v, vmin, vmax):
    return max(vmin, min(v, vmax))

def normalize_angle(rad):
    while rad > math.pi: rad -= 2*math.pi
    while rad < -math.pi: rad += 2*math.pi
    return rad

# ---------- Zero & smoothing ----------
bend1_zero = None
bend2_zero = None
bend1_prev = 0.0
bend2_prev = 0.0

def on_key(evt):
    global BEND_AXIS_1, BEND_AXIS_2, bend1_zero, bend2_zero
    k = evt.key
    if k == "1":
        BEND_AXIS_1 = "roll" if BEND_AXIS_1 == "pitch" else "pitch"
        print(f"🔄 Toggled bend axis for bone1: now {BEND_AXIS_1}")
    elif k == "2":
        BEND_AXIS_2 = "roll" if BEND_AXIS_2 == "pitch" else "pitch"
        print(f"🔄 Toggled bend axis for bone2: now {BEND_AXIS_2}")
    elif k == "z":
        bend1_zero = None
        bend2_zero = None
        print("✅ Re-zero calibration requested (put hand flat now)")

scene.bind("keydown", on_key)

# ---------- Main loop ----------
valid_seen = False
buffer = ""

while True:
    try:
        # --- buffered parser for < ... > frames ---
        chunk = ser.read(ser.in_waiting or 1).decode("utf-8", errors="ignore")
        if chunk:
            buffer += chunk

        while "<" in buffer and ">" in buffer:
            start = buffer.index("<")
            end   = buffer.index(">", start)
            frame = buffer[start+1:end].strip()
            buffer = buffer[end+1:]

            parts = [p.strip() for p in frame.split(",")]
            if len(parts) != 12:
                print("Skipping malformed frame:", frame)
                continue

            # --- parse values ---
            q0, q1, q2, q3 = [float(parts[i]) for i in range(4)]
            rollB  = -math.atan2(2*(q0*q1 + q2*q3), 1 - 2*(q1*q1 + q2*q2))
            pitchB =  math.asin( 2*(q0*q2 - q3*q1))
            yawB   = -math.atan2(2*(q0*q3 + q1*q2), 1 - 2*(q2*q2 + q3*q3))

            rollB, pitchB = pitchB, rollB

            roll1_deg  = float(parts[4]); pitch1_deg = float(parts[5])
            roll2_deg  = float(parts[6]); pitch2_deg = float(parts[7])
            system = int(parts[8]); gyro = int(parts[9]); accel = int(parts[10]); mag = int(parts[11])

            roll1_deg , pitch1_deg = pitch1_deg , roll1_deg
            roll2_deg , pitch2_deg = pitch2_deg , roll2_deg


            # Compute bends
            bend1_raw = math.radians(pitch1_deg if BEND_AXIS_1=="pitch" else roll1_deg) * SIGN_P1 * GAIN_1
            bend2_raw = math.radians(pitch2_deg if BEND_AXIS_2=="pitch" else roll2_deg) * SIGN_P2 * GAIN_2

            if bend1_zero is None: bend1_zero = bend1_raw
            if bend2_zero is None: bend2_zero = bend2_raw

            bend1 = normalize_angle(bend1_raw - bend1_zero)
            bend2 = normalize_angle(bend2_raw - bend2_zero)

            if SMOOTH > 0:
                bend1 = (1.0-SMOOTH)*bend1_prev + SMOOTH*bend1
                bend2 = (1.0-SMOOTH)*bend2_prev + SMOOTH*bend2
            bend1_prev, bend2_prev = bend1, bend2

            if USE_CLAMP:
                bend1 = math.radians(clamp(math.degrees(bend1), CLAMP_MIN_DEG, CLAMP_MAX_DEG))
                bend2 = math.radians(clamp(math.degrees(bend2), CLAMP_MIN_DEG, CLAMP_MAX_DEG))

            # HUD
            hud.text = (f"Calib Sys:{system} G:{gyro} A:{accel} M:{mag} | Port:{PORT}\n"
                        f"MPU1 r={roll1_deg:.1f}° p={pitch1_deg:.1f}° [bend={BEND_AXIS_1}]\n"
                        f"MPU2 r={roll2_deg:.1f}° p={pitch2_deg:.1f}° [bend={BEND_AXIS_2}]\n"
                        "Keys: '1'=toggle bone1 axis, '2'=toggle bone2 axis, 'z'=re-zero\n")

            if not valid_seen:
                print("✅ First valid frame received")
                valid_seen = True

            # ---------- Update scene ----------
            if valid_seen:
                # Wrist
                kB, upB = rpy_to_axis_up(rollB, pitchB, yawB)
                wrist.axis = kB; wrist.up = upB; wrist.pos = vector(0,0,0)

                # Fingers
                yawF = yawB; rollF = rollB

                k1, up1 = rpy_to_axis_up(rollF, bend1, yawF)
                bone1.axis = k1; bone1.up = up1
                bone1.pos  = wrist.pos + kB*(wrist_len/2.0 + bone1_len/2.0)

                k2, up2 = rpy_to_axis_up(rollF, bend2, yawF)
                bone2.axis = k2; bone2.up = up2
                bone2.pos  = bone1.pos - k1*(bone1_len/2.0 + bone2_len/2.0)

        rate(60)

    except Exception as e:
        print("Error:", e)
        rate(60)
